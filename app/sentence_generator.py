import random # maybe not required?
from app import app, db
from sqlalchemy.sql.expression import func, select
from sqlalchemy import or_
from app.models import SentenceModel, WordList
from app.sentence_gen_statics import VOWELS, NOUN_EXCEPTIONS, SAME_IN_PLURAL, SAME_AS_ADJ
from app.sentence_gen_statics import WORDLIST_TAGS_ALLOWED, MODEL_TAGS_ALLOWED
from app.sentence_gen_statics import WORD_BLACKLIST, SPECIAL_WORDS


'''
    sentence_generator.py
    A sentence generator that generates pseudo-random sentences from sentence models.
    Words as well as sentence models are saved manually in database tables and later
    retrieved for sentence generation.

    Sentence models consist of tags, for the most part parts-of-speech or word 
    classes, based on The Brown University Standard Corpus of Present-Day American 
    English (https://en.wikipedia.org/wiki/Brown_Corpus) but customized to fit
    application, see sentence_gen_statics.py for full list of tags.
    

    Notes on usage:
    * Save words and their tags in database in all lowercase, even proper nouns
    such as people's names (capitalized automatically by program).

    * Save only words in their base form (nouns in singular, verbs in infinitive form).
    
    * Don't save regular adverbs (handled by program).
    
    * Don't save pronouns (handled by program).
    
    * Extra care is required when saving ADJECTIVES and VERBS. Correct transformation
    of certain of these requires knowing the number of syllables the word has,
    specifically if the word has one syllable or if it has more than one syllable.
    Inform program of this by adding '1' for one or '+' for more than one syllable
    to words' tags, e.g. 'VB+' for a verb with more than one syllable or 'JJ1' for
    an adjective with one syllable. Note that this is only required when saving new
    words in database, not when constructing and storing new sentence models.
    
    * Save sentence models in format: TAG/TAG/TAG/TAG..., e.g. 'NN/BEZ/JJ' which 
    translates to 'noun/is/adjective' which could, if the words are saved in database
    generate e.g. 'cake/is/delicious' -> Cake is delicious.
    
    * English is full of exceptions. Some of these are handled by the program. For
    example, some nouns (e.g. 'deer') is the same in plural (not 'deers'), some 
    adverbs look the same as their adjective counterparts (e.g. 'late' in 
    'I will be late', not 'I will be lately'). A number of these exceptions are stored
    in sentence_gen_statics.py. If you discover more words that don't look right
    when chewed by the generator, see if they fit in any of the exceptions lists
    or add them to the blacklist.

    * Not all word forms are saved explicitly in database:
        * Nouns are only saved in singular form, plural form is generated by 
          process_noun().
        * Adjectives are stored in base (positive) form only. Their comparative
          and superlative forms are generated by process_adj()
        * Verbs are stored in their base (infinitive) form and conjugated as needed 
          by process_verb().
        * Regular adverbs are not stored but instead generated from their adjective
          versions. Certain adverbs are stored, however, such as adverbs of place,
          e.g. 'indoors'.
        * Some special words are stored in a dictionary in sentence_gen_statics.py,
          they include pronouns and forms of 'be' and 'have'.

    * Sentence_generator aims to be able to generate grammatically correct sentences
    but it has several limitations and might fail. If a word is misbehaving,
    it can be added to WORD_BLACKLIST and forbidden from future entry. Current
    limitations, possibly subject to change include:
        * Program is limited to regular verbs. Entered irregular verbs
          will not conjugate correctly.
        * Program has no semantic component, i.e. sentences will probably not make
          any sense.
        * Pronouns are handled poorly. Program has no way of knowing who or what
          the pronoun is referring to, and therefore it can't know what gender
          pronoun to select.
        * Fails to pluralize certain nouns (ending in -i in plural, e.g.
          cactus - cacti)



    REGEXP-MATCHA??? SENTENCE MODELS I VALIDATE SENTENCE FORM
'''


# Main function
def generate_sentence():

    # get random sentence model from database
    sentence_model = random_sentence_model()
    
    # split model string into list
    model_list = sentence_model.sentence.split('/')

    sentence = ''

    # loop through model list
    for tag in model_list:
        # get word
        word = get_word(tag)
        # append word to sentence
        sentence += word + ' '

    # Format and return
    return sentence[0].capitalize() + sentence[1:-1] + '.'


# Get random sentence model from database
def random_sentence_model():
    sentence_model = SentenceModel.query.order_by(func.random()).first()
    return sentence_model


# Ask database for a word, process and return it to main function
def get_word(tag):

    # First check if word is in hardcoded special
    # words list or is a hardcoded PRONOUN
    if tag in SPECIAL_WORDS:
        return SPECIAL_WORDS[tag]
    else:
        # Get a word from database
        word = random_word(tag)
   
    # Process VERBs (all verb forms start with V)
    if tag.startswith('V'):
        return process_verb(word.word, word.tag, tag)

    # Process NOUNs
    elif tag.startswith('NN'):
        return process_noun(word.word, tag)

    # Process PROPER NOUNS
    elif tag.startswith('NP'):
        word = word.word.capitalize()
        # possessive
        if tag[-1] == '$':
            word = word + "'" if word.endswith('s') else word + "'s"
        return word
    
    # Process ADJECTIVES
    elif tag.startswith('JJ'):
        return process_adj(word.word, word.tag, tag)
    
    # Process ADVERBS
    elif tag.startswith('RB'):
        return process_adv(word.word, tag)

    # else just return the word
    else:
        return word.word


# Get random word from database matching part-of-speech tag
def random_word(tag):
    
    # Verbs - Get infinitive verb for all verb forms
    # All (and only) verb forms' tags start with 'V'
    if tag.startswith('V'):
        word = WordList.query.filter(or_(WordList.tag == 'VB1', WordList.tag == 'VB+')) \
            .order_by(func.random()).first()
    
    # Nouns - Get noun base form for all forms (singular and plural)
    elif tag.startswith('NN'):
        word = WordList.query.filter_by(tag='NN').order_by(func.random()).first()
    
    # Adverbs - Many adverbs are generated from adjectives (JJ)
    elif tag == 'RB' or tag.startswith('JJ'):
        word = WordList.query.filter(or_(WordList.tag == 'JJ1', WordList.tag == 'JJ+')) \
            .order_by(func.random()).first()
    
    # Proper nouns
    elif tag.startswith('NP'):
        # remove '$' if present
        NP_tag = tag[:-1] if tag.endswith('$') else tag
        word = WordList.query.filter_by(tag=NP_tag).order_by(func.random()).first()
    
    # if no special tense or anything is required, just query using tag argument
    else:
        word = WordList.query.filter_by(tag=tag).order_by(func.random()).first()

    # return word object
    return word


# Process nouns
def process_noun(noun, tag):
    
    # Singular form
    if tag == 'NN':
        return noun
    
    # Singular possessive
    elif tag == 'NN$':
        return noun + "'" if noun[-1] == 's' else noun + "'s"
    
    else:
        noun = pluralize(noun)
        # Plural form
        if tag == 'NNS':
            return noun
        # Plural possessive
        else:
            return noun + "'" if noun[-1] == 's' else noun + "'s"


def pluralize(noun):
    
    # some nouns don't change in plural form
    if noun in SAME_IN_PLURAL:
        return noun
    
    # if noun ends in 's', 'sh', 'ch', 'x', or 'z', 
    # add 'es' instead of 's'
    elif noun.endswith('s') or noun.endswith('sh') or \
        noun.endswith('ch') or noun.endswith('x') or \
        noun.endswith('z'):
        return noun + 'es'
    
    # if noun ends in 'f' or 'fe', usually 'f' is changed
    # to 've' before adding 's'
    elif noun.endswith('f'):
        if noun not in NOUN_EXCEPTIONS:
            noun = noun[:-1]
            return noun + 'ves'
    elif noun.endswith('fe'):
        if noun not in NOUN_EXCEPTIONS:
            return noun[:-2] + 'ves'
    
    # if last letter is 'y' and preceding letter is a 
    # consonant, replace 'y' with 'i', pluralize with 'es'
    elif end_cons_y(noun):
        noun = noun[:-1]
        return noun + 'ies'

    # if noun ends in 'o', usually pluralize with 'es'
    elif noun.endswith('o') and noun not in NOUN_EXCEPTIONS:
        return noun + 'es'

    # if noun ends in 'on' or 'um', remove and pluralize with 'a',
    # e.g. 'phenomenon' - 'phenomena'
    elif noun.endswith('on') or noun.endswith('um'):
        if noun not in NOUN_EXCEPTIONS:
            noun = noun[:-2]
            return noun + 'a'
        else:
            return noun + 's'

    # if nothing funky is going on, pluralize by just adding 's'
    else:
        return noun + 's'


# Process adjectives
def process_adj(adj, adj_tag, tag):
    '''
        Takes adj_tag which is the word's tag in the database, used
        to determine comparative & superlative forms (prefix or suffix)
    '''

    # if base form (positive) is requested, simply return word
    if tag == 'JJ':
        return adj

    # else it will be either comparative (JJR) or superlative (JJT)
    else:
        # set prefix for comparative and superlative forms
        adj_prefix = 'more ' if tag == 'JJR' else 'most '
        adj_suffix = 'er' if tag == 'JJR' else 'est'

        # one syllable adjectives
        if adj_tag == 'JJ1':
            # if word ends in 'e', remove 'e'
            if adj[-1:] == 'e':
                adj = adj[:-1]
            # if word ends in vowel and consonant, double consonant
            elif adj[-1] not in VOWELS and adj[-2] in VOWELS:
                adj += adj[-1]
            # add suffix and return
            return adj + adj_suffix
            
        # two or more syllable adjectives
        elif adj_tag == 'JJ+':
            # if word ends in 'y' replace with 'i'
            if adj.endswith('y'):
                adj = adj[:-1] + 'i'
                # add suffix and return
                return adj + adj_suffix
            # else add prefix ('more ' or 'most ') and return
            else:
                return adj_prefix + adj


# Process verbs
def process_verb(verb, verb_tag, tag):
    '''
        Gets tempus from tag argument, transforms verb accordingly.
        Gets verb_tag from database, used for conjugation
        (one syllable verbs get doubled ending consonants under
        certain conditions...)
        
    '''

    # if requested tag is verb base form (VB), simply return word
    if tag == 'VB':
        return verb
    else:
        # Present 3rd person singular
        if tag == 'VBZ':
            if end_cons_y(verb):
                verb = verb[:-1] + 'i'
                return verb + 'es'
            else:
                return verb + 's'
        else:
            # if last char is consonant and preceded by vowel, double consonant
            if verb[-1] not in VOWELS and verb[-2] in VOWELS:
                # WARNING NOT REALLY GOOD, ALSO HAS TO DO WITH SYLLABLE STRESS
                #  SO BEWARE WHEN ADDING WORDS
                if not verb[-3] in VOWELS and verb_tag == 'VB1':
                    if verb.endswith('c'):
                        verb += 'k'
                    elif verb[-1] not in ['h', 'w', 'x', 'y']:
                        verb += verb[-1]
            # remove last letter if it is 'e'
            elif verb[-1] == 'e' and verb[-2] not in VOWELS:
                verb = verb[:-1]
            
            # past tense
            if tag == 'VBD':
                if end_cons_y(verb):
                    # if last char is 'y' and preceded by a consonant, replace with 'i'
                    verb = verb[:-1] + 'i' 
                return verb + 'ed'
            
            # else it will be VBG (present participle)
            else:
                return verb + 'ing'


# Process adverbs
def process_adv(adv, tag):

    TRANSFORMABLE = ['RB', 'RBR', 'RBT']

    if tag in TRANSFORMABLE and adv not in SAME_AS_ADJ:
        # MAYBE FUNCTION FOR COMMON IRREGULAR ADVERBS?
        # if adv == 'good':
        #     return 'well'
        if end_cons_y(adv):
            adv = adv[:-1] + 'ily'
        elif adv.endswith('le') and adv[-3] not in VOWELS:
            adv = adv[:-1] + 'y'
        elif adv.endswith('ic'):
            if adv == 'public':
                adv += 'ly'
            else:
                adv += 'ally'
        else:
            if not adv.endswith('ly'):
                adv += 'ly'

    # else tag will be RBTM, RBPL or RBFR
    else:
        return adv

    # comparative adverb    
    if tag == 'RBR':
        # either add prefix or suffix
        if adv in SAME_AS_ADJ:
            if adv[-1:] == 'y':
                adv = adv[:-1] + 'i'
            return adv + 'er'
        else:
            return 'more ' + adv
    
    # superlative adverbs
    elif tag == 'RBT':
        if adv in SAME_AS_ADJ:
            if adv[-1:] == 'y':
                adv = adv[:-1] + 'i'
            return adv + 'est'
        else:
            return 'most ' + adv

    # else: RB (base form)
    else:
        return adv


# Check if last character is 'y' and is preceded by a consonant
def end_cons_y(word):
    if word[-1] == 'y' and word[-2] not in VOWELS:
        return True
    else:
        return False


# Check if tag is valid, used in WordForm to validate tag field
def check_word_tag(tag):
    if tag in WORDLIST_TAGS_ALLOWED.keys():
        return True
    else:
        return False


# Check sentence tags, used to validate SentenceForm tags
def check_sentence_tags(sentence):
    tags = sentence.split('/')
    for tag in tags:
        if tag not in MODEL_TAGS_ALLOWED and tag not in SPECIAL_WORDS:
            return tag
    return 'allowed'