import random 
from app import app, db
from sqlalchemy.sql.expression import func, select
from sqlalchemy import or_
from app.models import SentenceModel, WordList

# static assets
# sortera finare
from app.sentence_gen_statics import VOWELS, PRONOUNS, NOUN_EXCEPTIONS, SAME_IN_PLURAL, SAME_AS_ADJ
from app.sentence_gen_statics import WORDLIST_TAGS_ALLOWED, MODEL_TAGS_ALLOWED
from app.sentence_gen_statics import WORD_BLACKLIST, SPECIAL_WORDS, CONJUNCTIONS, PREPOSITIONS
from app.sentence_gen_statics import CARDINALS, ORDINALS, IRREGULAR_VERBS, TAG_OPTIONS

from app.sentence_gen_statics import NOUN, PROPER_NOUN, PRONOUN, ADJECTIVE
from app.sentence_gen_statics import VERB, ADVERB, PREPOSITION, CONJUNCTION
from app.sentence_gen_statics import CARDINAL, ORDINAL, DEF_ARTICLE, INDEF_ARTICLE
from app.sentence_gen_statics import SPECIAL

from app.sentence_gen_statics import SINGULAR, PLURAL, INHERIT
from app.sentence_gen_statics import POSITIVE, COMPARATIVE, SUPERLATIVE

from app.sentence_gen_statics import MALE, FEMALE, NEUTRAL

from app.sentence_gen_statics import INFINITIVE, PRESENT_TENSE, PRESENT_PART
from app.sentence_gen_statics import PAST_TENSE, PAST_PART


'''
    sentence_generator.py
    A sentence generator that generates pseudo-random sentences from sentence models.
    Words as well as sentence models are saved manually in database tables and later
    retrieved for sentence generation.

    Sentence models consist of tags, for the most part parts-of-speech or word 
    classes, based on The Brown University Standard Corpus of Present-Day American 
    English (https://en.wikipedia.org/wiki/Brown_Corpus) but customized to fit
    application, see sentence_gen_statics.py for full list of tags.
    

    Notes on usage:
    * Save words and their tags in database in all lowercase, even proper nouns
    such as people's names (capitalized automatically by program).

    * Save only words in their base form (nouns in singular, verbs in infinitive form).
    
    * Don't save regular adverbs (handled by program).
    
    * Don't save pronouns (handled by program).
    
    * Extra care is required when saving ADJECTIVES and VERBS. Correct transformation
    of certain of these requires knowing the number of syllables the word has,
    specifically if the word has one syllable or if it has more than one syllable.
    Inform program of this by adding '1' for one or '+' for more than one syllable
    to words' tags, e.g. 'VB+' for a verb with more than one syllable or 'JJ1' for
    an adjective with one syllable. Note that this is only required when saving new
    words in database, not when constructing and storing new sentence models.
    
    * Save sentence models in format: TAG/TAG/TAG/TAG..., e.g. 'NN/BEZ/JJ' which 
    translates to 'noun/is/adjective' which could, if the words are saved in database
    generate e.g. 'cake/is/delicious' -> Cake is delicious.
    
    * English is full of exceptions. Some of these are handled by the program. For
    example, some nouns (e.g. 'deer') is the same in plural (not 'deers'), some 
    adverbs look the same as their adjective counterparts (e.g. 'late' in 
    'I will be late', not 'I will be lately'). A number of these exceptions are stored
    in sentence_gen_statics.py. If you discover more words that don't look right
    when chewed by the generator, see if they fit in any of the exceptions lists
    or add them to the blacklist.

    * Not all word forms are saved explicitly in database:
        * Nouns are only saved in singular form, plural form is generated by 
          process_noun().
        * Adjectives are stored in base (positive) form only. Their comparative
          and superlative forms are generated by process_adj()
        * Verbs are stored in their base (infinitive) form and conjugated as needed 
          by process_verb().
        * Regular adverbs are not stored but instead generated from their adjective
          versions. Certain adverbs are stored, however, such as adverbs of place,
          e.g. 'indoors'.
        * Some special words are stored in a dictionary in sentence_gen_statics.py,
          they include pronouns and forms of 'be' and 'have'.

    * Sentence_generator aims to be able to generate grammatically correct sentences
    but it has several limitations and might fail. If a word is misbehaving,
    it can be added to WORD_BLACKLIST and forbidden from future entry. Current
    limitations, possibly subject to change include:
        * Program is limited to regular verbs. Entered irregular verbs
          will not conjugate correctly.
        * Program has no semantic component, i.e. sentences will probably not make
          any sense.
        * Pronouns are handled poorly. Program has no way of knowing who or what
          the pronoun is referring to, and therefore it can't know what gender
          pronoun to select.
        * Fails to pluralize certain nouns (ending in -i in plural, e.g.
          cactus - cacti)
'''


class Sentence:
    ''' Creates new sentence object. Actual sentence is a list (self.sentence)
        of word objects accessible through self.sentence[index].word (I THINK) '''

    def __init__(self, model):
        # gets model as string, convert to list
        self.mod_list = model.split('/')
    
        # Randomly generate subtags if needed (if tags contain '??')
        self.mod_list = self.set_random_tags(self.mod_list)

        # store subject, verb, object indices in dictionary
        self.SVO_ind = self.get_SVO_ind(self.mod_list)

        # /hmm, kanske najs?
        # self.SUBJECT = SVO_ind['subj']
        # self.VERB = SVO_ind['verb']
        # self.OBJECT = SVO_ind['obj']

        # make sure there's a subject
        # if self.SVO_ind['subj'] == None:
        #     # RAISE HELL
        #     pass

        # initialize sentence (list of 'x', to be replaced)
        self.sentence = list('x' * len(self.mod_list))
        
        # get subject
        self.current_word = self.SVO_ind['subj']
        self.sentence[self.SVO_ind['subj']] = self.get_word(self.mod_list[self.SVO_ind['subj']])

        # get verb
        if 'verb' in self.SVO_ind.keys():
            self.current_word = self.SVO_ind['verb']
            self.sentence[self.SVO_ind['verb']] = self.get_word(self.mod_list[self.SVO_ind['verb']])
            
        # get object
        if 'obj' in self.SVO_ind.keys():
            self.current_word = self.SVO_ind['obj']
            self.sentence[self.SVO_ind['obj']] = self.get_word(self.mod_list[self.SVO_ind['obj']])

        # initialize list of indefinite article indices
        self.ai_inds = []

        # get rest of words
        for i in range(len(self.sentence)):

            # update current working word index
            self.current_word = i

            if self.sentence[i] == 'x':

                # get indefinite article index (because we need all nouns before
                # we can choose correct articles for them)
                if self.mod_list[i].split('.')[0] == INDEF_ARTICLE:
                    self.ai_inds.append(i)
                # else get a word
                else:
                    self.sentence[i] = self.get_word(self.mod_list[i])

        # get any indefinite articles
        if self.ai_inds:
            for ind in self.ai_inds:
                self.current_word = ind
                self.sentence[ind] = self.get_indef_article(ind)

        # try to get an object:
            # check if verb is associated with any categories:
                # get object from category 
                # (e.g.) if verb is "eat" and object is a noun, select random
                # noun from nouns with category tag "food"
            # else just get an object
        
        # if we need adjectives, check what word it serves to describe, see if
        # that word has any associations that might be relevant, then possibly
        # get fitting adjective (from right category)

        # maybe something similar for adverbs?

        # get remaining words


    def set_random_tags(self, mod_list):
        """ Checks model for '??' and replaces with random fitting tag, stored
            in dict TAG_OPTIONS in statics. """

        for tag, i in zip(mod_list, range(len(mod_list))):
            subtags = tag.split('.')

            # loop through list of subtags, replace '??' with
            # value from dictionary in statics
            for subtag, j in zip(subtags, range(len(subtags))):
                if subtag == '??':
                    self.mod_list[i] = self.mod_list[i].replace(self.mod_list[i] \
                        .split('.')[j], random.choice(TAG_OPTIONS[subtags[0]][j]))

        return mod_list


    def get_SVO_ind(self, tag_list):
        """ create a dictionary storing indices of subject, verb, object """
        
        indices = {}

        for tag in tag_list:
            for subtag in tag.split('.'):
                if subtag == 's':
                    indices['subj'] = tag_list.index(tag)
                elif subtag == 'o':
                    indices['obj'] = tag_list.index(tag)
                elif tag.split('.')[0] == 'VB':
                    indices['verb'] = tag_list.index(tag)
        
        return indices


    def get_word(self, tag):
        """ Word-getter function. Calls functions to retrieve words by word class.
            Each of those functions create a new word object, either by retrieving
            a word from database, from statics (pronouns, conjunctions), or 
            sometimes raw words from sentence model. """

        get_func_dict = {
            NOUN: self.get_noun,
            PROPER_NOUN: self.get_proper_noun,
            PRONOUN: self.get_pronoun,
            ADJECTIVE: self.get_adj,
            VERB: self.get_verb,
            ADVERB: self.get_adv,
            PREPOSITION: self.get_prep,
            CONJUNCTION: self.get_conj,  # CONJUNCTIONS
            CARDINAL: self.get_card,  # CARDINAL NUMBER 
            ORDINAL: self.get_ord,   # ORDINAL NUMBER
            DEF_ARTICLE: self.get_def_article,
            SPECIAL: self.get_spec
        }

        word = get_func_dict[tag.split('.')[0]](tag)

        return word
        

    def get_verb(self, tag):
        ''' Get a verb from database, conjugate it properly and return it.
                
            Verb sentence model rules:
            0: Always 'VB' 
            1: 'I', 'Z', 'D', 'G'  # ADD 'N' past participle
            2: TYPE KANSKE? ACTION, 
            '''            

        tags = tag.split('.')

        verb = (WordList.query
            .filter_by(tag=tags[0])
            .order_by(func.random()).first())

        # if not infinitive form, conjugate
        if tags[1] != INFINITIVE:

            # if verb.word == 'be': # kanske ocks√• do, have??
            # CONJUGATE 'be'
            if verb.irregular == 1 and (tags[1] == PAST_TENSE or tags[1] == PAST_PART) and verb.word in list(IRREGULAR_VERBS):
                verb.word = IRREGULAR_VERBS[verb.word][tags[1]]
            else:
                verb.word = self.conjugate(verb.word, verb.mult_syll, tags[1])

        # IRREGULAR VERBS???

        return verb

    
    def conjugate(self, verb, mult_syll, tag):
        ''' Conjugate and return correct form of verb. '''

        # Present tense
        if tag == PRESENT_TENSE:
            subj_tag = self.mod_list[self.SVO_ind['subj']].split('.')
            # for pronouns, only transform third person singular
            if subj_tag[0] == PRONOUN:
                if subj_tag[2] == SINGULAR and subj_tag[3] == '3':
                    return self.present_tensify(verb)
                else:
                    return verb
            return self.present_tensify(verb)
            
        # Else either past tense or present participle
        else:
            # if last char is consonant and preceded by vowel, double consonant
            if verb[-1] not in VOWELS and verb[-2] in VOWELS:
                # WARNING NOT REALLY GOOD, ALSO HAS TO DO WITH SYLLABLE STRESS
                #  SO BEWARE WHEN ADDING WORDS
                if verb[-3] not in VOWELS and mult_syll == 0:
                    if verb.endswith('c'):
                        verb += 'k'
                    elif verb[-1] not in ['h', 'w', 'x', 'y']:
                        verb += verb[-1]
            # remove last letter if it is 'e'
            elif verb[-1] == 'e' and verb[-2] not in VOWELS:
                verb = verb[:-1]
            
            # past tense
            if tag == PAST_TENSE:
                if self.end_cons_y(verb):
                    # if last char is 'y' and preceded by a consonant, replace with 'i'
                    verb = verb[:-1] + 'i' 
                return verb + 'ed'
            
            # else it will be present participle
            else:
                return verb + 'ing'

    
    def present_tensify(self, verb):
        if self.end_cons_y(verb):
            verb = verb[:-1] + 'i'
            return verb + 'es'
        else:
            return verb + 's'


    def get_noun(self, tag):
        ''' Get a noun word object from database, check if it needs to be pluralized
            or transformed for possession and then return it.
            
            Noun sentence model rules:
            0: Always 'NN'
            1: 's', 'o', '$', 'n'   # subject, object, possessive, neutral
            2: 'S', 'P'             # singular, plural '''


        tags = tag.split('.')

        noun = (WordList.query.filter_by(tag=tags[0])
                              .order_by(func.random()).first())

        # pluralize
        if tags[2] == PLURAL:
            noun.word = self.pluralize(noun.word)

        # handle possessive case
        if tags[1] == '$':
             noun.word += "'" if noun.word[-1] == 's' else "'s"

        return noun


    def pluralize(self, noun):
        """ Find and return proper plural form for noun """

        # some nouns don't change in plural form
        if noun in SAME_IN_PLURAL:
            return noun
        
        # if noun ends in 's', 'sh', 'ch', 'x', or 'z', 
        # add 'es' instead of 's'
        elif noun.endswith('s') or noun.endswith('sh') or \
            noun.endswith('ch') or noun.endswith('x') or \
            noun.endswith('z'):
            return noun + 'es'
        
        # if noun ends in 'f' or 'fe', usually 'f' is changed
        # to 've' before adding 's'
        elif noun.endswith('f'):
            if noun not in NOUN_EXCEPTIONS:
                noun = noun[:-1]
                return noun + 'ves'
        elif noun.endswith('fe'):
            if noun not in NOUN_EXCEPTIONS:
                return noun[:-2] + 'ves'
        
        # if last letter is 'y' and preceding letter is a 
        # consonant, replace 'y' with 'i', pluralize with 'es'
        elif self.end_cons_y(noun):
            noun = noun[:-1]
            return noun + 'ies'

        # if noun ends in 'o', usually pluralize with 'es'
        elif noun.endswith('o') and noun not in NOUN_EXCEPTIONS:
            return noun + 'es'

        # if noun ends in 'on' or 'um', remove and pluralize with 'a',
        # e.g. 'phenomenon' - 'phenomena'
        elif noun.endswith('on') or noun.endswith('um'):
            if noun not in NOUN_EXCEPTIONS:
                noun = noun[:-2]
                return noun + 'a'
            else:
                return noun + 's'

        # if nothing funky is going on, pluralize by just adding 's'
        else:
            return noun + 's'


    def end_cons_y(self, word):
        """ Check if last character is 'y' and is preceded by a consonant """

        if word[-1] == 'y' and word[-2] not in VOWELS:
            return True
        else:
            return False


    def get_proper_noun(self, tag):
        """ Create proper noun object. 
            Get a word, transform for possession if needed and return
            
            proper noun sentence model rules:
            0: Always 'NP'
            1: 's', 'o', '$', 'n'   # subject, object, possessive, neutral """

        proper_noun = (WordList.query.filter_by(tag=tag.split('.')[0])
                                     .order_by(func.random()).first())

        proper_noun.word = proper_noun.word.capitalize()

        # handle possessive case
        if tag.split('.')[1] == '$':
             proper_noun.word += "'" if proper_noun.word[-1] == 's' else "'s"

        return proper_noun

                
    def get_pronoun(self, tag):
        """ Pronouns aren't stored in database. Instead they're statically stored 
            in application (sentence_gen_statics.py), in nested dictionary form.

            First get base pronoun, then figure out the correct form.
        
            Pronoun sentence model rules:
            0: Always 'PN'                          
            1: 's', 'o', 'ref_s', 'ref_o', 'reflex' # subject, object or referencing them (actually called possessive adjective and possessive pronouns) and reflexive
            2: 'S', 'P', 'IN'                       # singular or plural, inherit (IN)
            3: '1', '2', '3', 'IN'                  # first, second or third person or inherit
            4: 'MM', 'FF', 'NN', 'IN'               # gender or inherit """

        tags = tag.split('.')

        # establish base pronoun
        pronoun = self.get_base_pronoun(tag)

        # get correct form
        if tags[1] == 'o':
            pronoun.word = PRONOUNS[pronoun.word]['obj']
        elif tags[1] == 'ref_s':
            pronoun.word = PRONOUNS[pronoun.word]['poss_adj']
        elif tags[1] == 'ref_o':
            pronoun.word = PRONOUNS[pronoun.word]['poss_pronoun']
        elif tags[1] == 'reflex':
            pronoun.word = PRONOUNS[pronoun.word]['reflex']

        return pronoun


    def get_base_pronoun(self, tag):

        tags = tag.split('.')

        pronoun = WordList(word='', gender=NEUTRAL, tag=tags[0])

        # check inheritance
        if tags[2] == INHERIT:
            # if referencing a word, inherit from that word object
            if tags[1] == 'ref_s':
                pronoun = self.inherit_pronoun(tags, self.sentence[self.SVO_ind['subj']], pronoun)
            elif tags[1] == 'ref_o':
                pronoun = self.inherit_pronoun(tags, self.sentence[self.SVO_ind['obj']], pronoun)

        # singular, i.e. I, you, he, she, it
        elif tags[2] == SINGULAR:
            # first person
            if tags[3] == '1':
                pronoun.word = 'I'
            # second person
            elif tags[3] == '2':
                pronoun.word = 'you'
            # third person
            elif tags[3] == '3':
                # male
                if tags[4] == MALE:
                    pronoun.word = 'he'
                    pronoun.gender = MALE
                # female
                elif tags[4] == FEMALE:
                    pronoun.word = 'she'
                    pronoun.gender = FEMALE
                # default to neutral
                else:
                    pronoun.word = 'it'
                    pronoun.gender = NEUTRAL

        # plural, i.e. either we, you, they
        elif tags[2] == 'P':
            # first person
            if tags[3] == '1':
                pronoun.word = 'we'
            # second person
            elif tags[3] == '2':
                pronoun.word = 'you'
            # default to third person
            else:
                pronoun.word = 'they'

        # default to random
        else:
            pronoun.word = random.choice(list(PRONOUNS.keys()))

            if pronoun.word == 'he':
                pronoun.gender = MALE
            elif pronoun.word == 'she':
                pronoun.gender = FEMALE

        return pronoun


    def inherit_pronoun(self, tags, ref, pronoun):
        ''' First checks if referenced word is a pronoun. If it is, return it.
            If it isn't a pronoun, it will be either a proper noun or a noun,
            so a gender check will suffice to select correct pronoun. If not
            male or female, function defaults to neutral, i.e. 'it'. '''

        if ref.word in list(PRONOUNS):
            pronoun.word = ref.word
            pronoun.gender = ref.gender
        elif ref.gender == MALE:
            pronoun.word = 'he'
            pronoun.gender = MALE
        elif ref.gender == FEMALE:
            pronoun.word = 'she'
            pronoun.gender = FEMALE
        else:
            pronoun.word = 'it'
            pronoun.gender = NEUTRAL

        return pronoun


    def get_adj(self, tag):
        """ Adjective object
        
            Sentence model rules:
            0: 'JJ'
            1: 'P', 'C', 'S'                # positive, comparative, superlative
            2: 'ref_s', 'ref_o', 'ref_n'    # describing subject, object, neutral """

        tags = tag.split('.')

        adj = (WordList.query.filter_by(tag=tags[0])
                       .order_by(func.random()).first())

        # handle comparative, superlative forms
        if tags[1] != POSITIVE:
            adj.word = self.transform_adj(adj, tags[1]) 

        return adj

    
    def transform_adj(self, adj, form):
        """ Transform adjective to comparative or superlative form """

        transform = {'C':{'pref':'more ','suff':'er'}, \
                     'S':{'pref':'most ','suff':'est'}}
        
        word = adj.word
        mult_syllables = adj.mult_syll

        if adj.irregular == '0':
            # one syllable adjectives
            if mult_syllables == '0':
                # if word ends in 'e', remove 'e'
                if word[-1] == 'e':
                    word = word[:-1]
                # if word ends in vowel and consonant, double consonant
                elif word[-1] not in VOWELS and word[-2] in VOWELS:
                    if not word[-1] == 'n':
                        word += word[-1]
                # add suffix and return
                return word + transform[form]['suff']

            # two or more syllable adjectives
            elif mult_syllables == '1':
                # if word ends in 'y' replace with 'i'
                if word.endswith('y'):
                    word = word[:-1] + 'i'
                    # add suffix and return
                    return word + transform[form]['suff']
                # else add prefix ('more ' or 'most ') and return
                else:
                    return transform[form]['pref'] + word            
        # else HANDLE IRREGULAR ADJECTIVES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        else:
            return word

    
    def get_adv(self, tag):
        """ Adverb object
        
            Sentence model rules:
            0: 'RB'
            1: 'P', 'C', 'S'            # positive, comparative, superlative 
            2: 'N', 'T', 'F', 'P'       # 'Normal', Time, Frequency, Place
            
            More to be added later. """

        tags = tag.split('.')

        # get "normal" adverb, i.e. adjective-based
        if tags[2] == 'N':
            adv = (WordList.query.filter_by(tag=ADJECTIVE)
                                 .order_by(func.random()).first())

            # set tag to adverb
            adv.tag = ADVERB

            # adverbify
            if adv.irregular == 0:
                adv.word = self.adverbify(adv.word) 

            # handle comparative, superlative forms
            if tags[1] != POSITIVE and adv.irregular == 0:
                adv.word = self.transform_adv(adv.word, tags[1])
        else:
            # FLYTTA TILL STATICS??????
            subtypes = {'T':'time',
                        'F':'frequency',
                        'P':'place'}

            adv = (WordList.query.filter_by(tag=tags[0], subtype=subtypes[tags[2]])
                                 .order_by(func.random()).first())

        return adv


    def adverbify(self, adv):
        """ Turn adjective into adverb. Checks some grammatical rules
            and transforms adjective. """

        if self.end_cons_y(adv):
            adv = adv[:-1] + 'ily'
        elif adv.endswith('le') and adv[-3] not in VOWELS:
            adv = adv[:-1] + 'y'
        elif adv.endswith('ic'):
            if adv == 'public':
                adv += 'ly'
            else:
                adv += 'ally'
        else:
            if not adv.endswith('ly') and adv not in SAME_AS_ADJ:
                adv += 'ly'
        
        return adv


    def transform_adv(self, adv, form):
        """ Transform adverb into its comparative or superlative form. """

        transform = {'C':{'pref':'more ','suff':'er'}, \
                     'S':{'pref':'most ','suff':'est'}}

        # either add prefix or suffix
        if adv in SAME_AS_ADJ:
            if adv[-1] == 'y':
                adv = adv[:-1] + 'i'
            return adv + transform[form]['suff']
        else:
            return transform[form]['pref'] + adv


    def get_def_article(self, tag):
        """ Create word object for definite article, i.e. 'the'. """

        article = WordList(tag=tag, word='the')

        return article


    def get_conj(self, tag):
        """ Create conjunction object.
        
        Sentence model rules:
        0: 'CN'
        1: desired conjunction word or '??' for random """

        tags = tag.split('.')

        conj = WordList(tag=tags[0], word=tags[1])

        return conj


    def get_prep(self, tag):
        """ Create preposition object.
        
        Sentence model rules:
        0: 'IN'
        1: desired preposition word or '??' for random """

        tags = tag.split('.')

        prep = WordList(tag=tags[0], word=tags[1])

        return prep

    
    def get_card(self, tag):
        """ Create cardinal number object. 
            Can generate numbers ranging from 1 to 9999.
        
            Sentence model rules:
            0: 'CD'
            1: '1', '2', '3', '4', '??'     # length or random """

        tags = tag.split('.')

        num_len = int(tags[1])

        # generate a number between 1 and maximum specified by num_len
        num = random.randint(1, int('9' * num_len) + 1)

        text_num = self.textify(num)

        cardinal = WordList(tag=tags[0], word=text_num)

        return cardinal

    
    def textify(self, num):
        """ Translates a number into text """

        text_num = ''

        if num < 21:
            text_num = CARDINALS[num]
        else:
            num = str(num)
            if 0 < int(num[-2:]) < 21:
                text_num = CARDINALS[int(num[-2:])]
            else:
                # get second-from-right number (tens)
                if num[-2] != '0':
                    text_num = CARDINALS[int(num[-2]) * 10]
                # get last digit, append to string
                if num[-1] != '0':
                    text_num += '-' + CARDINALS[int(num[-1])]
            # get hundreds number
            if len(num) > 2 and int(num[-3]) != 0:
                hundreds_num = CARDINALS[int(num[-3])] + ' hundred'
                if int(num[-2:]) > 0:
                    hundreds_num += ' and '
                text_num = hundreds_num + text_num
            # get thousands number
            if len(num) > 3:
                thousands_num = CARDINALS[int(num[0])] + ' thousand'
                if int(num[-3:]) > 0:
                    thousands_num += ', '
                text_num = thousands_num + text_num

        return text_num


    def get_ord(self, tag):
        """ Create ordinal number object. 
            Simply retrieve a random ordinal number from a static list.
            
            Model rules:
            0: 'OD' """

        ord = WordList(tag=tag.split('.')[0], word=random.choice(ORDINALS))

        return ord


    def get_indef_article(self, i):
        """ Create indefinite article object and choose the right one. """

        article = WordList(tag=INDEF_ARTICLE)

        # if next word is noun, get its article
        if self.sentence[i+1].tag == NOUN:
            article.word = self.sentence[i].article
        # else check if next word starts with a vowel (not great solution but oh well)
        elif self.sentence[i+1].word[0] in VOWELS:
            article.word = 'an'
        # default to 'a'
        else:
            article.word = 'a'

        return article

    
    def get_spec(self, tag):
        """ Special words function simply sets second subtag to word and
            returns object.
            
            Rules:
            0: 'SPEC'
            1: any word """

        tags = tag.split('.')
        special_word = WordList(tag=tags[0], word=tags[1])
        return special_word


# Main function
def generate_sentence():

    # get random sentence model from database
    sentence_model = random_sentence_model()

    # create new sentence object 
    new_sentence = Sentence(sentence_model.sentence)

    # return sentence (list of word objects)
    return new_sentence.sentence


# Get random sentence model from database
def random_sentence_model():
    sentence_model = SentenceModel.query.order_by(func.random()).first()
    return sentence_model


# Check if tag is valid, used in WordForm to validate tag field
def check_word_tag(tag):
    if tag in WORDLIST_TAGS_ALLOWED.keys():
        return True
    else:
        return False


# Check sentence tags, used to validate SentenceForm tags
def check_sentence_tags(sentence):
    tags = sentence.split('/')
    for tag in tags:
        if tag not in MODEL_TAGS_ALLOWED and tag not in SPECIAL_WORDS:
            return tag
    return 'allowed'